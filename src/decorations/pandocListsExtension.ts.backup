import { Extension, StateField, EditorState, RangeSetBuilder } from '@codemirror/state';
import { EditorView, ViewPlugin, ViewUpdate, Decoration, DecorationSet, WidgetType } from '@codemirror/view';
import { editorLivePreviewField, setTooltip } from 'obsidian';
import { PandocListsSettings } from '../settings';
import { isStrictPandocList, isStrictPandocHeading, ValidationContext } from '../pandocValidator';

// Widget for rendering fancy list markers
class FancyListMarkerWidget extends WidgetType {
    private controller: AbortController;

    constructor(private marker: string, private type: string, private view?: EditorView, private pos?: number) {
        super();
        this.controller = new AbortController();
    }

    toDOM() {
        const span = document.createElement('span');
        span.className = 'cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1';
        span.style.cursor = 'text';
        const innerSpan = document.createElement('span');
        innerSpan.className = 'list-number';
        innerSpan.textContent = this.marker;
        span.appendChild(innerSpan);
        
        // Handle click events to place cursor
        if (this.view && this.pos !== undefined) {
            span.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.view!.dispatch({
                    selection: { anchor: this.pos! }
                });
                this.view!.focus();
            }, { signal: this.controller.signal });
        }
        
        return span;
    }

    eq(other: FancyListMarkerWidget) {
        return other.marker === this.marker && other.pos === this.pos;
    }

    ignoreEvent(event: Event) {
        return event.type !== 'mousedown';
    }

    destroy() {
        this.controller.abort();
    }
}

// Widget for example list markers
class ExampleListMarkerWidget extends WidgetType {
    private controller: AbortController;

    constructor(private number: number, private view?: EditorView, private pos?: number) {
        super();
        this.controller = new AbortController();
    }

    toDOM() {
        const span = document.createElement('span');
        span.className = 'cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1';
        span.style.cursor = 'text';
        const innerSpan = document.createElement('span');
        innerSpan.className = 'list-number';
        innerSpan.textContent = `(${this.number}) `;
        span.appendChild(innerSpan);
        
        // Handle click events to place cursor
        if (this.view && this.pos !== undefined) {
            span.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.view!.dispatch({
                    selection: { anchor: this.pos! }
                });
                this.view!.focus();
            }, { signal: this.controller.signal });
        }
        
        return span;
    }

    eq(other: ExampleListMarkerWidget) {
        return other.number === this.number && other.pos === this.pos;
    }

    ignoreEvent(event: Event) {
        return event.type !== 'mousedown';
    }

    destroy() {
        this.controller.abort();
    }
}

// Widget for definition list bullets
class DefinitionBulletWidget extends WidgetType {
    private controller: AbortController;

    constructor(private view?: EditorView, private pos?: number) {
        super();
        this.controller = new AbortController();
    }
    
    toDOM() {
        const span = document.createElement('span');
        span.className = 'cm-formatting cm-formatting-list cm-list-1';
        span.style.cursor = 'text';
        span.textContent = 'â€¢ ';
        
        // Handle click events to place cursor
        if (this.view && this.pos !== undefined) {
            span.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.view!.dispatch({
                    selection: { anchor: this.pos! }
                });
                this.view!.focus();
            }, { signal: this.controller.signal });
        }
        
        return span;
    }
    
    eq(other: DefinitionBulletWidget) {
        return other.pos === this.pos;
    }

    ignoreEvent(event: Event) {
        return event.type !== 'mousedown';
    }

    destroy() {
        this.controller.abort();
    }
}


// Widget for hash auto-numbering
class HashListMarkerWidget extends WidgetType {
    private controller: AbortController;

    constructor(private number: number, private view?: EditorView, private pos?: number) {
        super();
        this.controller = new AbortController();
    }

    toDOM() {
        const span = document.createElement('span');
        span.className = 'cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1';
        span.style.cursor = 'text';
        const innerSpan = document.createElement('span');
        innerSpan.className = 'list-number';
        innerSpan.textContent = `${this.number}. `;
        span.appendChild(innerSpan);
        
        // Handle click events to place cursor
        if (this.view && this.pos !== undefined) {
            span.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.view!.dispatch({
                    selection: { anchor: this.pos! }
                });
                this.view!.focus();
            }, { signal: this.controller.signal });
        }
        
        return span;
    }

    eq(other: HashListMarkerWidget) {
        return other.number === this.number && other.pos === this.pos;
    }

    ignoreEvent(event: Event) {
        return event.type !== 'mousedown';
    }

    destroy() {
        this.controller.abort();
    }
}

// Widget for example references
class ExampleReferenceWidget extends WidgetType {
    constructor(private number: number, private tooltipText?: string) {
        super();
    }

    toDOM() {
        const span = document.createElement('span');
        span.className = 'pandoc-example-reference';
        span.textContent = `(${this.number})`;
        
        // Add tooltip if available
        if (this.tooltipText) {
            setTooltip(span, this.tooltipText, { delay: 300 });
        }
        
        return span;
    }

    eq(other: ExampleReferenceWidget) {
        return other.number === this.number && other.tooltipText === this.tooltipText;
    }
}

// Simple view plugin without state field to avoid errors
const pandocListsPlugin = (getSettings: () => PandocListsSettings) => ViewPlugin.fromClass(
    class {
        decorations: DecorationSet;
        exampleLabels: Map<string, number> = new Map();
        exampleContent: Map<string, string> = new Map();

        constructor(view: EditorView) {
            this.scanExampleLabels(view);
            this.decorations = this.buildDecorations(view);
        }

        update(update: ViewUpdate) {
            if (update.docChanged || update.viewportChanged || update.selectionSet) {
                if (update.docChanged) {
                    this.scanExampleLabels(update.view);
                }
                this.decorations = this.buildDecorations(update.view);
            }
        }

        isListItemForValidation(line: string): boolean {
            // Check for various list patterns
            return !!(
                line.match(/^(\s*)(#\.)(\s+)/) || // Hash auto-numbering
                line.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/) || // Fancy lists
                line.match(/^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/) || // Example lists
                line.match(/^[~:]\s+/) || // Definition lists
                line.match(/^(\s*)[-*+]\s+/) || // Unordered lists
                line.match(/^(\s*)[0-9]+[.)]\s+/) // Regular numbered lists
            );
        }

        scanExampleLabels(view: EditorView) {
            this.exampleLabels.clear();
            this.exampleContent.clear();
            let counter = 1;
            const docText = view.state.doc.toString();
            const lines = docText.split('\n');
            
            for (const line of lines) {
                const match = line.match(/^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+(.*)$/);
                if (match) {
                    const label = match[2];
                    const content = match[3].trim();
                    if (!this.exampleLabels.has(label)) {
                        this.exampleLabels.set(label, counter);
                        // Store the content after the marker
                        if (content) {
                            this.exampleContent.set(label, content);
                        }
                    }
                    counter++;
                } else {
                    const unlabeledMatch = line.match(/^(\s*)\(@\)\s+/);
                    if (unlabeledMatch) {
                        counter++;
                    }
                }
            }
        }

        buildDecorations(view: EditorView): DecorationSet {
            const builder = new RangeSetBuilder<Decoration>();
            
            // Check if we're in live preview mode - if not, return empty decorations
            const isLivePreview = view.state.field(editorLivePreviewField);
            if (!isLivePreview) {
                return builder.finish();
            }
            
            // Get settings for strict mode checking
            const settings = getSettings();
            const lines = view.state.doc.toString().split('\n');
            
            // Track cursor position to preserve source mode only when cursor is in the marker
            const selection = view.state.selection.main;
            const cursorPos = selection.head;
            
            // Collect all decorations first
            const decorations: Array<{from: number, to: number, decoration: Decoration}> = [];
            
            // Track hash list numbering
            let hashCounter = 1;
            
            // In strict mode, pre-validate list blocks
            const invalidListBlocks = new Set<number>();
            if (settings.strictPandocMode) {
                let listBlockStart = -1;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const isCurrentList = this.isListItemForValidation(line);
                    const prevIsListOrEmpty = i > 0 && (this.isListItemForValidation(lines[i - 1]) || lines[i - 1].trim() === '');
                    
                    // Check if previous line is a definition term (special case)
                    const prevIsDefinitionTerm = i > 0 && lines[i - 1].trim() && 
                        !lines[i - 1].match(/^[~:]\s+/) && 
                        !lines[i - 1].match(/^(    |\t)/) &&
                        line.match(/^[~:]\s+/);
                    
                    if (isCurrentList && listBlockStart === -1) {
                        // Start of a new list block
                        listBlockStart = i;
                        // Check if it has proper empty line before (unless first line or after a definition term)
                        if (i > 0 && lines[i - 1].trim() !== '' && !prevIsDefinitionTerm) {
                            // Mark entire block as invalid
                            for (let j = i; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
                                invalidListBlocks.add(j);
                            }
                        }
                    } else if (!isCurrentList && listBlockStart !== -1) {
                        // End of list block
                        // Check if there's proper empty line after (unless it's an empty line)
                        if (line.trim() !== '') {
                            // Mark entire previous block as invalid
                            for (let j = listBlockStart; j < i; j++) {
                                invalidListBlocks.add(j);
                            }
                        }
                        listBlockStart = -1;
                    }
                    
                    // Check for capital letter spacing issue
                    if (isCurrentList) {
                        const capitalLetterMatch = line.match(/^(\s*)([A-Z])(\.)(\s+)/);
                        if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
                            // Mark entire block as invalid
                            for (let j = i; j >= 0 && this.isListItemForValidation(lines[j]); j--) {
                                invalidListBlocks.add(j);
                            }
                            for (let j = i + 1; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
                                invalidListBlocks.add(j);
                            }
                        }
                    }
                }
            }
            
            // Process entire document for consistent numbering
            for (let lineNum = 1; lineNum <= view.state.doc.lines; lineNum++) {
                const line = view.state.doc.line(lineNum);
                const lineText = line.text;
                
                // Create validation context
                const validationContext: ValidationContext = {
                    lines: lines,
                    currentLine: lineNum - 1 // 0-based index
                };
                
                // Check for hash auto-numbering FIRST
                const hashMatch = lineText.match(/^(\s*)(#\.)(\s+)/);
                if (hashMatch) {
                    // Check if this list item is in an invalid block
                    if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
                        continue; // Skip rendering if in an invalid list block
                    }
                    
                    const indent = hashMatch[1];
                    const marker = hashMatch[2];
                    const space = hashMatch[3];
                    
                    const markerStart = line.from + indent.length;
                    const markerEnd = line.from + indent.length + marker.length + space.length;
                    
                    // Check if cursor is within the marker area
                    const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
                    
                    // Add line decoration for proper styling
                    decorations.push({
                        from: line.from,
                        to: line.from,
                        decoration: Decoration.line({
                            class: 'HyperMD-list-line HyperMD-list-line-1',
                            attributes: {
                                style: 'text-indent: -29px; padding-inline-start: 29px;'
                            }
                        })
                    });
                    
                    // Only replace the marker if cursor is not within it
                    if (!cursorInMarker) {
                        decorations.push({
                            from: markerStart,
                            to: markerEnd,
                            decoration: Decoration.replace({
                                widget: new HashListMarkerWidget(hashCounter, view, markerStart)
                            })
                        });
                    }
                    
                    // Wrap the rest of the line
                    decorations.push({
                        from: line.from + indent.length + marker.length + space.length,
                        to: line.to,
                        decoration: Decoration.mark({
                            class: 'cm-list-1'
                        })
                    });
                    
                    hashCounter++;
                    continue;
                }
                
                // Check for fancy list markers (A. B. i. ii. etc)
                const fancyMatch = lineText.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/);
                if (fancyMatch && !lineText.match(/^(\s*)([0-9]+[.)])/)) {
                    // Check if this list item is in an invalid block
                    if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
                        continue; // Skip rendering if in an invalid list block
                    }
                    
                    const indent = fancyMatch[1];
                    const marker = fancyMatch[2];
                    const markerWithSpace = marker + fancyMatch[5];
                    
                    const markerStart = line.from + indent.length;
                    const markerEnd = line.from + indent.length + markerWithSpace.length;
                    
                    // Check if cursor is within the marker area
                    const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
                    
                    // Add line decoration for proper styling
                    decorations.push({
                        from: line.from,
                        to: line.from,
                        decoration: Decoration.line({
                            class: 'HyperMD-list-line HyperMD-list-line-1',
                            attributes: {
                                style: `text-indent: -${markerWithSpace.length * 7}px; padding-inline-start: ${markerWithSpace.length * 7}px;`
                            }
                        })
                    });
                    
                    // Only replace the marker if cursor is not within it
                    if (!cursorInMarker) {
                        decorations.push({
                            from: markerStart,
                            to: markerEnd,
                            decoration: Decoration.replace({
                                widget: new FancyListMarkerWidget(markerWithSpace, 'fancy', view, markerStart),
                                inclusive: false
                            })
                        });
                    }
                    
                    // Wrap the rest of the line
                    decorations.push({
                        from: line.from + indent.length + markerWithSpace.length,
                        to: line.to,
                        decoration: Decoration.mark({
                            class: 'cm-list-1'
                        })
                    });
                    
                    continue;
                }
                
                // Check for example list markers (@)
                const exampleMatch = lineText.match(/^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/);
                if (exampleMatch) {
                    // Check if this list item is in an invalid block
                    if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
                        continue; // Skip rendering if in an invalid list block
                    }
                    
                    const indent = exampleMatch[1];
                    const fullMarker = exampleMatch[2];
                    const label = exampleMatch[3];
                    const space = exampleMatch[4];
                    
                    const markerStart = line.from + indent.length;
                    const markerEnd = line.from + indent.length + fullMarker.length + space.length;
                    
                    // Check if cursor is within the marker area
                    const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
                    
                    let exampleNumber = 1;
                    
                    if (label && this.exampleLabels.has(label)) {
                        exampleNumber = this.exampleLabels.get(label)!;
                    } else {
                        // Count unlabeled examples before this line
                        let tempCounter = 1;
                        for (let i = 1; i < line.number; i++) {
                            const prevLine = view.state.doc.line(i).text;
                            if (prevLine.match(/^(\s*)\(@\)\s+/)) {
                                tempCounter++;
                            }
                        }
                        exampleNumber = tempCounter;
                    }
                    
                    // Add line decoration for proper styling
                    decorations.push({
                        from: line.from,
                        to: line.from,
                        decoration: Decoration.line({
                            class: 'HyperMD-list-line HyperMD-list-line-1',
                            attributes: {
                                style: 'text-indent: -29px; padding-inline-start: 29px;'
                            }
                        })
                    });
                    
                    // Only replace the marker if cursor is not within it
                    if (!cursorInMarker) {
                        decorations.push({
                            from: markerStart,
                            to: markerEnd,
                            decoration: Decoration.replace({
                                widget: new ExampleListMarkerWidget(exampleNumber, view, markerStart)
                            })
                        });
                    }
                    
                    // Wrap the rest of the line
                    decorations.push({
                        from: line.from + indent.length + fullMarker.length + space.length,
                        to: line.to,
                        decoration: Decoration.mark({
                            class: 'cm-list-1'
                        })
                    });
                    
                    continue;
                }
                
                // Check for definition items FIRST before checking terms
                // Check for definition items FIRST before checking terms
                const defItemMatch = lineText.match(/^([~:])(\s+)/);
                if (defItemMatch) {
                    // Check if this list item is in an invalid block
                    if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
                        continue; // Skip rendering if in an invalid list block
                    }
                    
                    const marker = defItemMatch[1];
                    const space = defItemMatch[2];
                    
                    const markerStart = line.from;
                    const markerEnd = line.from + marker.length + space.length;
                    
                    // Check if cursor is within the marker area
                    const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
                    
                    // Only replace the marker if cursor is not within it
                    if (!cursorInMarker) {
                        decorations.push({
                            from: markerStart,
                            to: markerEnd,
                            decoration: Decoration.replace({
                                widget: new DefinitionBulletWidget(view, markerStart)
                            })
                        });
                    }
                    continue; // Skip term check for definition lines
                }
                
                // Check if we're in a definition list context
                // A line starting with 4+ spaces after a definition marker is part of the definition
                const indentMatch = lineText.match(/^(    |\t)(.*)$/);
                if (indentMatch) {
                    // Check if we're after a definition marker
                    let inDefinitionContext = false;
                    for (let checkLine = lineNum - 1; checkLine >= 1; checkLine--) {
                        const prevLine = view.state.doc.line(checkLine);
                        const prevText = prevLine.text;
                        
                        // If we find a definition marker, we're in definition context
                        if (prevText.match(/^[~:]\s+/)) {
                            inDefinitionContext = true;
                            break;
                        }
                        // If we find a non-empty, non-indented line that's not a definition
                        if (prevText.trim() && !prevText.match(/^(    |\t)/) && !prevText.match(/^[~:]\s+/)) {
                            // Could still be in context if this is a term followed by definition
                            break;
                        }
                    }
                    
                    if (inDefinitionContext) {
                        const content = indentMatch[2];
                        
                        // Only apply decorations if there's actual content after the indent
                        // This prevents cursor issues on empty indented lines
                        if (content && content.trim()) {
                            // Apply line decoration to override code block styling
                            decorations.push({
                                from: line.from,
                                to: line.from,
                                decoration: Decoration.line({
                                    class: 'cm-pandoc-definition-paragraph',
                                    attributes: {
                                        'data-definition-content': 'true'
                                    }
                                })
                            });
                            
                            // Mark the entire line content to prevent code styling
                            decorations.push({
                                from: line.from,
                                to: line.to,
                                decoration: Decoration.mark({
                                    class: 'pandoc-definition-content-text'
                                })
                            });
                        }
                        continue; // Skip further processing for this line
                    }
                }
                
                // Check for definition terms - can be directly followed by definition or have empty line
                if (lineText.trim() && !lineText.match(/^[~:]\s*/) && !indentMatch) {
                    // Check next line(s) for definition marker
                    let isDefinitionTerm = false;
                    let checkOffset = 1;
                    
                    // First check immediate next line
                    if (line.number + 1 <= view.state.doc.lines) {
                        const nextLine = view.state.doc.line(line.number + 1);
                        const nextText = nextLine.text;
                        
                        // Direct definition (no empty line)
                        if (nextText.match(/^[~:]\s+/)) {
                            isDefinitionTerm = true;
                        }
                        // Empty line followed by definition
                        else if (nextText.trim() === '' && line.number + 2 <= view.state.doc.lines) {
                            const lineAfterEmpty = view.state.doc.line(line.number + 2);
                            if (lineAfterEmpty.text.match(/^[~:]\s+/)) {
                                isDefinitionTerm = true;
                            }
                        }
                    }
                    
                    if (isDefinitionTerm) {
                        decorations.push({
                            from: line.from,
                            to: line.to,
                            decoration: Decoration.mark({
                                class: 'cm-strong cm-pandoc-definition-term'
                            })
                        });
                    }
                }
                
                // Process example references inline
                const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
                let match;
                while ((match = refRegex.exec(lineText)) !== null) {
                    const label = match[1];
                    if (this.exampleLabels.has(label)) {
                        const refStart = line.from + match.index;
                        const refEnd = line.from + match.index + match[0].length;
                        
                        // Check if cursor is within this reference
                        const cursorInRef = cursorPos >= refStart && cursorPos <= refEnd;
                        
                        // Only replace if cursor is not within the reference
                        if (!cursorInRef) {
                            const number = this.exampleLabels.get(label)!;
                            const tooltipText = this.exampleContent.get(label);
                            decorations.push({
                                from: refStart,
                                to: refEnd,
                                decoration: Decoration.replace({
                                    widget: new ExampleReferenceWidget(number, tooltipText)
                                })
                            });
                        }
                    }
                }
            }
            
            // Sort decorations by from position
            decorations.sort((a, b) => a.from - b.from || a.to - b.to);
            
            // Add sorted decorations to builder
            for (const {from, to, decoration} of decorations) {
                builder.add(from, to, decoration);
            }
            
            return builder.finish();
        }
    },
    {
        decorations: v => v.decorations
    }
);

export function pandocListsExtension(getSettings: () => PandocListsSettings): Extension {
    return [
        pandocListsPlugin(getSettings),
        EditorView.baseTheme({
            '.cm-pandoc-definition-term': {
                textDecoration: 'underline'
            },
            '.cm-pandoc-definition-paragraph': {
                // Don't add extra padding - indentation is already handled by spaces/tabs
                textIndent: '0 !important'
            },
            '.cm-pandoc-definition-paragraph .cm-hmd-indented-code': {
                background: 'transparent !important',
                border: 'none !important',
                borderRadius: '0 !important',
                padding: '0 !important',
                color: 'inherit !important',
                fontFamily: 'inherit !important',
                fontSize: 'inherit !important'
            },
            '.pandoc-definition-content-text': {
                background: 'transparent !important',
                border: 'none !important',
                padding: '0 !important',
                color: 'inherit !important',
                fontFamily: 'inherit !important'
            },
            '.cm-pandoc-definition-paragraph .cm-indent': {
                // Keep indent visible for proper cursor positioning
                opacity: '1'
            },
            '.pandoc-example-reference': {
                color: 'var(--text-accent)',
                cursor: 'pointer'
            },
            '.pandoc-example-reference:hover': {
                textDecoration: 'underline'
            }
        })
    ];
}