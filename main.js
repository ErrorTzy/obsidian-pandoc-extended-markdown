/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PandocListsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/decorations/pandocListsExtension.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var FancyListMarkerWidget = class extends import_view.WidgetType {
  constructor(marker, type) {
    super();
    this.marker = marker;
    this.type = type;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol";
    span.style.color = "var(--list-marker-color)";
    span.textContent = this.marker;
    return span;
  }
  eq(other) {
    return other.marker === this.marker;
  }
};
var ExampleListMarkerWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol";
    span.style.color = "var(--list-marker-color)";
    span.textContent = `(${this.number}) `;
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var DefinitionBulletWidget = class extends import_view.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.textContent = "\u2022 ";
    return span;
  }
  eq(other) {
    return true;
  }
};
var HashListMarkerWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol";
    span.style.color = "var(--list-marker-color)";
    span.textContent = `${this.number}. `;
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var ExampleReferenceWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "pandoc-example-reference";
    span.style.color = "var(--text-accent)";
    span.textContent = `(${this.number})`;
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var pandocListsPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.exampleLabels = /* @__PURE__ */ new Map();
      this.scanExampleLabels(view);
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.selectionSet) {
        if (update.docChanged) {
          this.scanExampleLabels(update.view);
        }
        this.decorations = this.buildDecorations(update.view);
      }
    }
    scanExampleLabels(view) {
      this.exampleLabels.clear();
      let counter = 1;
      const docText = view.state.doc.toString();
      const lines = docText.split("\n");
      for (const line of lines) {
        const match = line.match(/^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+/);
        if (match) {
          const label = match[2];
          if (!this.exampleLabels.has(label)) {
            this.exampleLabels.set(label, counter);
          }
          counter++;
        } else if (line.match(/^(\s*)\(@\)\s+/)) {
          counter++;
        }
      }
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const selection = view.state.selection.main;
      const cursorLine = view.state.doc.lineAt(selection.head).number;
      const decorations = [];
      let hashCounter = 1;
      for (let lineNum = 1; lineNum <= view.state.doc.lines; lineNum++) {
        const line = view.state.doc.line(lineNum);
        if (line.number === cursorLine) {
          if (line.text.match(/^(\s*)#\.\s+/)) {
            hashCounter++;
          }
          continue;
        }
        const lineText = line.text;
        const hashMatch = lineText.match(/^(\s*)(#\.)(\s+)/);
        if (hashMatch) {
          const indent = hashMatch[1];
          const marker = hashMatch[2];
          const space = hashMatch[3];
          decorations.push({
            from: line.from + indent.length,
            to: line.from + indent.length + marker.length + space.length,
            decoration: import_view.Decoration.replace({
              widget: new HashListMarkerWidget(hashCounter)
            })
          });
          hashCounter++;
          continue;
        }
        const fancyMatch = lineText.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/);
        if (fancyMatch && !lineText.match(/^(\s*)([0-9]+[.)])/)) {
          const indent = fancyMatch[1];
          const marker = fancyMatch[2];
          const markerWithSpace = marker + fancyMatch[5];
          decorations.push({
            from: line.from + indent.length,
            to: line.from + indent.length + markerWithSpace.length,
            decoration: import_view.Decoration.replace({
              widget: new FancyListMarkerWidget(markerWithSpace, "fancy")
            })
          });
          continue;
        }
        const exampleMatch = lineText.match(/^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/);
        if (exampleMatch) {
          const indent = exampleMatch[1];
          const fullMarker = exampleMatch[2];
          const label = exampleMatch[3];
          const space = exampleMatch[4];
          let exampleNumber = 1;
          if (label && this.exampleLabels.has(label)) {
            exampleNumber = this.exampleLabels.get(label);
          } else {
            let tempCounter = 1;
            for (let i = 1; i < line.number; i++) {
              const prevLine = view.state.doc.line(i).text;
              if (prevLine.match(/^(\s*)\(@\)\s+/)) {
                tempCounter++;
              }
            }
            exampleNumber = tempCounter;
          }
          decorations.push({
            from: line.from + indent.length,
            to: line.from + indent.length + fullMarker.length + space.length,
            decoration: import_view.Decoration.replace({
              widget: new ExampleListMarkerWidget(exampleNumber)
            })
          });
          continue;
        }
        const defItemMatch = lineText.match(/^(\s*)([~:])(\s+)/);
        if (defItemMatch) {
          const indent = defItemMatch[1];
          const marker = defItemMatch[2];
          const space = defItemMatch[3];
          decorations.push({
            from: line.from + indent.length,
            to: line.from + indent.length + marker.length + space.length,
            decoration: import_view.Decoration.replace({
              widget: new DefinitionBulletWidget()
            })
          });
          continue;
        }
        if (lineText.trim() && !lineText.match(/^(\s*)[~:]\s+/)) {
          const nextLineNum = line.number + 1;
          if (nextLineNum <= view.state.doc.lines) {
            const nextLine = view.state.doc.line(nextLineNum);
            const nextText = nextLine.text;
            if (nextText.match(/^(\s*)[~:]\s+/)) {
              decorations.push({
                from: line.from,
                to: line.to,
                decoration: import_view.Decoration.mark({
                  class: "pandoc-definition-term"
                })
              });
            }
          }
        }
        const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
        let match;
        while ((match = refRegex.exec(lineText)) !== null) {
          const label = match[1];
          if (this.exampleLabels.has(label)) {
            const number = this.exampleLabels.get(label);
            decorations.push({
              from: line.from + match.index,
              to: line.from + match.index + match[0].length,
              decoration: import_view.Decoration.replace({
                widget: new ExampleReferenceWidget(number)
              })
            });
          }
        }
      }
      decorations.sort((a, b) => a.from - b.from || a.to - b.to);
      for (const { from, to, decoration } of decorations) {
        builder.add(from, to, decoration);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
function pandocListsExtension() {
  return [
    pandocListsPlugin,
    import_view.EditorView.baseTheme({
      ".pandoc-definition-term": {
        fontWeight: "bold",
        textDecoration: "underline"
      },
      ".pandoc-example-reference": {
        color: "var(--text-accent)",
        cursor: "pointer"
      },
      ".pandoc-example-reference:hover": {
        textDecoration: "underline"
      },
      ".cm-line:has(.cm-formatting-list)": {
        textIndent: "-1.5em",
        paddingLeft: "2em"
      }
    })
  ];
}

// src/parsers/fancyListParser.ts
var ROMAN_UPPER = /^[IVXLCDM]+$/;
var ROMAN_LOWER = /^[ivxlcdm]+$/;
var ALPHA_UPPER = /^[A-Z]+$/;
var ALPHA_LOWER = /^[a-z]+$/;
var DECIMAL = /^[0-9]+$/;
function parseFancyListMarker(line) {
  const match = line.match(/^(\s*)(([a-zA-Z]+|[ivxlcdmIVXLCDM]+|[0-9]+|#)([.)]))\s+/);
  if (!match) {
    return null;
  }
  const indent = match[1];
  const marker = match[2];
  const value = match[3];
  const delimiter = match[4];
  let type;
  if (value === "#") {
    type = "hash";
  } else if (DECIMAL.test(value)) {
    return null;
  } else if (ROMAN_UPPER.test(value)) {
    type = "upper-roman";
  } else if (ROMAN_LOWER.test(value)) {
    type = "lower-roman";
  } else if (ALPHA_UPPER.test(value)) {
    type = "upper-alpha";
  } else if (ALPHA_LOWER.test(value)) {
    type = "lower-alpha";
  } else {
    return null;
  }
  return {
    indent,
    marker,
    type,
    delimiter,
    value: value === "#" ? void 0 : value
  };
}

// src/parsers/exampleListParser.ts
function parseExampleListMarker(line) {
  const match = line.match(/^(\s*)(\(@([a-zA-Z0-9_-]+)?\))\s+/);
  if (!match) {
    return null;
  }
  return {
    indent: match[1],
    originalMarker: match[2],
    label: match[3]
  };
}

// src/parsers/definitionListParser.ts
function parseDefinitionListMarker(line) {
  const termMatch = line.match(/^([^\n:~]+)$/);
  if (termMatch && !line.includes("*") && !line.includes("-") && !line.match(/^\s*\d+[.)]/)) {
    const nextLineIndex = line.indexOf("\n");
    if (nextLineIndex === -1 || nextLineIndex === line.length - 1) {
      return {
        type: "term",
        indent: "",
        marker: "",
        content: termMatch[1].trim()
      };
    }
  }
  const defMatch = line.match(/^(\s*)([~:])\s+(.+)/);
  if (defMatch) {
    return {
      type: "definition",
      indent: defMatch[1],
      marker: defMatch[2],
      content: defMatch[3]
    };
  }
  return null;
}

// src/parsers/readingModeProcessor.ts
function processReadingMode(element, context) {
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    null
  );
  const nodesToProcess = [];
  while (walker.nextNode()) {
    nodesToProcess.push(walker.currentNode);
  }
  const exampleMap = /* @__PURE__ */ new Map();
  let exampleCounter = 1;
  nodesToProcess.forEach((node) => {
    const text = node.textContent || "";
    const lines = text.split("\n");
    lines.forEach((line) => {
      const exampleInfo = parseExampleListMarker(line);
      if (exampleInfo) {
        if (exampleInfo.label && !exampleMap.has(exampleInfo.label)) {
          exampleMap.set(exampleInfo.label, exampleCounter);
          exampleCounter++;
        } else if (!exampleInfo.label) {
          exampleCounter++;
        }
      }
    });
  });
  nodesToProcess.forEach((node) => {
    const parent = node.parentNode;
    if (!parent) return;
    const text = node.textContent || "";
    const lines = text.split("\n");
    const newElements = [];
    lines.forEach((line, lineIndex) => {
      if (lineIndex > 0) {
        newElements.push(document.createTextNode("\n"));
      }
      const fancyMarker = parseFancyListMarker(line);
      if (fancyMarker) {
        const span = document.createElement("span");
        span.className = `pandoc-list-${fancyMarker.type}`;
        span.textContent = fancyMarker.marker + " ";
        newElements.push(span);
        const rest = line.substring(fancyMarker.indent.length + fancyMarker.marker.length + 1);
        if (rest) {
          newElements.push(document.createTextNode(rest));
        }
        return;
      }
      const exampleMarker = parseExampleListMarker(line);
      if (exampleMarker) {
        let number = 1;
        if (exampleMarker.label && exampleMap.has(exampleMarker.label)) {
          number = exampleMap.get(exampleMarker.label);
        }
        const span = document.createElement("span");
        span.className = "pandoc-example-list";
        span.textContent = `(${number}) `;
        newElements.push(span);
        const rest = line.substring(exampleMarker.indent.length + exampleMarker.originalMarker.length + 1);
        if (rest) {
          newElements.push(document.createTextNode(rest));
        }
        return;
      }
      const defMarker = parseDefinitionListMarker(line);
      if (defMarker) {
        if (defMarker.type === "term") {
          const strong = document.createElement("strong");
          const u = document.createElement("u");
          u.textContent = defMarker.content;
          strong.appendChild(u);
          newElements.push(strong);
        } else {
          const span = document.createElement("span");
          span.textContent = "\u2022 ";
          newElements.push(span);
          newElements.push(document.createTextNode(defMarker.content));
        }
        return;
      }
      const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
      let lastIndex = 0;
      let match;
      while ((match = refRegex.exec(line)) !== null) {
        if (match.index > lastIndex) {
          newElements.push(document.createTextNode(line.substring(lastIndex, match.index)));
        }
        const label = match[1];
        if (exampleMap.has(label)) {
          const span = document.createElement("span");
          span.className = "pandoc-example-reference";
          span.textContent = `(${exampleMap.get(label)})`;
          newElements.push(span);
        } else {
          newElements.push(document.createTextNode(match[0]));
        }
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < line.length) {
        newElements.push(document.createTextNode(line.substring(lastIndex)));
      } else if (lastIndex === 0) {
        newElements.push(document.createTextNode(line));
      }
    });
    newElements.forEach((elem) => {
      parent.insertBefore(elem, node);
    });
    parent.removeChild(node);
  });
}

// src/main.ts
var PandocListsPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Pandoc Lists plugin");
    this.registerEditorExtension(pandocListsExtension());
    this.registerMarkdownPostProcessor((element, context) => {
      processReadingMode(element, context);
    });
    console.log("Pandoc Lists plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Pandoc Lists plugin");
  }
};
