/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PandocListsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/decorations/pandocListsExtension.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian = require("obsidian");
var FancyListMarkerWidget = class extends import_view.WidgetType {
  constructor(marker, type) {
    super();
    this.marker = marker;
    this.type = type;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1";
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = this.marker;
    span.appendChild(innerSpan);
    return span;
  }
  eq(other) {
    return other.marker === this.marker;
  }
};
var ExampleListMarkerWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1";
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `(${this.number}) `;
    span.appendChild(innerSpan);
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var DefinitionBulletWidget = class extends import_view.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-list-1";
    span.textContent = "\u2022 ";
    return span;
  }
  eq(other) {
    return true;
  }
};
var HashListMarkerWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1";
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `${this.number}. `;
    span.appendChild(innerSpan);
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var ExampleReferenceWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "pandoc-example-reference";
    span.style.color = "var(--text-accent)";
    span.textContent = `(${this.number})`;
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var pandocListsPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.exampleLabels = /* @__PURE__ */ new Map();
      this.scanExampleLabels(view);
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.selectionSet) {
        if (update.docChanged) {
          this.scanExampleLabels(update.view);
        }
        this.decorations = this.buildDecorations(update.view);
      }
    }
    scanExampleLabels(view) {
      this.exampleLabels.clear();
      let counter = 1;
      const docText = view.state.doc.toString();
      const lines = docText.split("\n");
      for (const line of lines) {
        const match = line.match(/^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+/);
        if (match) {
          const label = match[2];
          if (!this.exampleLabels.has(label)) {
            this.exampleLabels.set(label, counter);
          }
          counter++;
        } else if (line.match(/^(\s*)\(@\)\s+/)) {
          counter++;
        }
      }
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const isLivePreview = view.state.field(import_obsidian.editorLivePreviewField);
      if (!isLivePreview) {
        return builder.finish();
      }
      const selection = view.state.selection.main;
      const cursorPos = selection.head;
      const decorations = [];
      let hashCounter = 1;
      for (let lineNum = 1; lineNum <= view.state.doc.lines; lineNum++) {
        const line = view.state.doc.line(lineNum);
        const lineText = line.text;
        const hashMatch = lineText.match(/^(\s*)(#\.)(\s+)/);
        if (hashMatch) {
          const indent = hashMatch[1];
          const marker = hashMatch[2];
          const space = hashMatch[3];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + marker.length + space.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          decorations.push({
            from: line.from,
            to: line.from,
            decoration: import_view.Decoration.line({
              class: "HyperMD-list-line HyperMD-list-line-1",
              attributes: {
                style: "text-indent: -29px; padding-inline-start: 29px;"
              }
            })
          });
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new HashListMarkerWidget(hashCounter)
              })
            });
          }
          decorations.push({
            from: line.from + indent.length + marker.length + space.length,
            to: line.to,
            decoration: import_view.Decoration.mark({
              class: "cm-list-1"
            })
          });
          hashCounter++;
          continue;
        }
        const fancyMatch = lineText.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/);
        if (fancyMatch && !lineText.match(/^(\s*)([0-9]+[.)])/)) {
          const indent = fancyMatch[1];
          const marker = fancyMatch[2];
          const markerWithSpace = marker + fancyMatch[5];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + markerWithSpace.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          decorations.push({
            from: line.from,
            to: line.from,
            decoration: import_view.Decoration.line({
              class: "HyperMD-list-line HyperMD-list-line-1",
              attributes: {
                style: `text-indent: -${markerWithSpace.length * 7}px; padding-inline-start: ${markerWithSpace.length * 7}px;`
              }
            })
          });
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new FancyListMarkerWidget(markerWithSpace, "fancy")
              })
            });
          }
          decorations.push({
            from: line.from + indent.length + markerWithSpace.length,
            to: line.to,
            decoration: import_view.Decoration.mark({
              class: "cm-list-1"
            })
          });
          continue;
        }
        const exampleMatch = lineText.match(/^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/);
        if (exampleMatch) {
          const indent = exampleMatch[1];
          const fullMarker = exampleMatch[2];
          const label = exampleMatch[3];
          const space = exampleMatch[4];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + fullMarker.length + space.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          let exampleNumber = 1;
          if (label && this.exampleLabels.has(label)) {
            exampleNumber = this.exampleLabels.get(label);
          } else {
            let tempCounter = 1;
            for (let i = 1; i < line.number; i++) {
              const prevLine = view.state.doc.line(i).text;
              if (prevLine.match(/^(\s*)\(@\)\s+/)) {
                tempCounter++;
              }
            }
            exampleNumber = tempCounter;
          }
          decorations.push({
            from: line.from,
            to: line.from,
            decoration: import_view.Decoration.line({
              class: "HyperMD-list-line HyperMD-list-line-1",
              attributes: {
                style: "text-indent: -29px; padding-inline-start: 29px;"
              }
            })
          });
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new ExampleListMarkerWidget(exampleNumber)
              })
            });
          }
          decorations.push({
            from: line.from + indent.length + fullMarker.length + space.length,
            to: line.to,
            decoration: import_view.Decoration.mark({
              class: "cm-list-1"
            })
          });
          continue;
        }
        const defItemMatch = lineText.match(/^(\s*)([~:])(\s+)/);
        if (defItemMatch) {
          const indent = defItemMatch[1];
          const marker = defItemMatch[2];
          const space = defItemMatch[3];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + marker.length + space.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new DefinitionBulletWidget()
              })
            });
          }
          continue;
        }
        if (lineText.trim() && !lineText.match(/^(\s*)[~:]\s+/)) {
          let isDefinitionTerm = false;
          for (let offset = 1; offset <= 2 && line.number + offset <= view.state.doc.lines; offset++) {
            const checkLine = view.state.doc.line(line.number + offset);
            const checkText = checkLine.text;
            if (checkText.match(/^(\s*)[~:]\s+/)) {
              isDefinitionTerm = true;
              break;
            } else if (checkText.trim() && offset === 1) {
              break;
            }
          }
          if (isDefinitionTerm) {
            decorations.push({
              from: line.from,
              to: line.to,
              decoration: import_view.Decoration.mark({
                class: "cm-strong cm-pandoc-definition-term"
              })
            });
          }
        }
        const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
        let match;
        while ((match = refRegex.exec(lineText)) !== null) {
          const label = match[1];
          if (this.exampleLabels.has(label)) {
            const refStart = line.from + match.index;
            const refEnd = line.from + match.index + match[0].length;
            const cursorInRef = cursorPos >= refStart && cursorPos <= refEnd;
            if (!cursorInRef) {
              const number = this.exampleLabels.get(label);
              decorations.push({
                from: refStart,
                to: refEnd,
                decoration: import_view.Decoration.replace({
                  widget: new ExampleReferenceWidget(number)
                })
              });
            }
          }
        }
      }
      decorations.sort((a, b) => a.from - b.from || a.to - b.to);
      for (const { from, to, decoration } of decorations) {
        builder.add(from, to, decoration);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
function pandocListsExtension() {
  return [
    pandocListsPlugin,
    import_view.EditorView.baseTheme({
      ".cm-pandoc-definition-term": {
        textDecoration: "underline"
      },
      ".pandoc-example-reference": {
        color: "var(--text-accent)",
        cursor: "pointer"
      },
      ".pandoc-example-reference:hover": {
        textDecoration: "underline"
      }
    })
  ];
}

// src/parsers/fancyListParser.ts
var ROMAN_UPPER = /^[IVXLCDM]+$/;
var ROMAN_LOWER = /^[ivxlcdm]+$/;
var ALPHA_UPPER = /^[A-Z]+$/;
var ALPHA_LOWER = /^[a-z]+$/;
var DECIMAL = /^[0-9]+$/;
function parseFancyListMarker(line) {
  const match = line.match(/^(\s*)(([a-zA-Z]+|[ivxlcdmIVXLCDM]+|[0-9]+|#)([.)]))\s+/);
  if (!match) {
    return null;
  }
  const indent = match[1];
  const marker = match[2];
  const value = match[3];
  const delimiter = match[4];
  let type;
  if (value === "#") {
    type = "hash";
  } else if (DECIMAL.test(value)) {
    return null;
  } else if (ROMAN_UPPER.test(value)) {
    type = "upper-roman";
  } else if (ROMAN_LOWER.test(value)) {
    type = "lower-roman";
  } else if (ALPHA_UPPER.test(value)) {
    type = "upper-alpha";
  } else if (ALPHA_LOWER.test(value)) {
    type = "lower-alpha";
  } else {
    return null;
  }
  return {
    indent,
    marker,
    type,
    delimiter,
    value: value === "#" ? void 0 : value
  };
}

// src/parsers/exampleListParser.ts
function parseExampleListMarker(line) {
  const match = line.match(/^(\s*)(\(@([a-zA-Z0-9_-]+)?\))\s+/);
  if (!match) {
    return null;
  }
  return {
    indent: match[1],
    originalMarker: match[2],
    label: match[3]
  };
}

// src/parsers/definitionListParser.ts
function parseDefinitionListMarker(line) {
  const termMatch = line.match(/^([^\n:~]+)$/);
  if (termMatch && !line.includes("*") && !line.includes("-") && !line.match(/^\s*\d+[.)]/)) {
    const nextLineIndex = line.indexOf("\n");
    if (nextLineIndex === -1 || nextLineIndex === line.length - 1) {
      return {
        type: "term",
        indent: "",
        marker: "",
        content: termMatch[1].trim()
      };
    }
  }
  const defMatch = line.match(/^(\s*)([~:])\s+(.+)/);
  if (defMatch) {
    return {
      type: "definition",
      indent: defMatch[1],
      marker: defMatch[2],
      content: defMatch[3]
    };
  }
  return null;
}

// src/parsers/readingModeProcessor.ts
function processReadingMode(element, context) {
  const elementsToProcess = element.querySelectorAll("p, li");
  const exampleMap = /* @__PURE__ */ new Map();
  let exampleCounter = 1;
  elementsToProcess.forEach((elem) => {
    const text = elem.textContent || "";
    const lines = text.split("\n");
    lines.forEach((line) => {
      const exampleInfo = parseExampleListMarker(line);
      if (exampleInfo) {
        if (exampleInfo.label && !exampleMap.has(exampleInfo.label)) {
          exampleMap.set(exampleInfo.label, exampleCounter);
          exampleCounter++;
        } else if (!exampleInfo.label) {
          exampleCounter++;
        }
      }
    });
  });
  elementsToProcess.forEach((elem) => {
    if (elem.closest("h1, h2, h3, h4, h5, h6")) {
      return;
    }
    const walker = document.createTreeWalker(
      elem,
      NodeFilter.SHOW_TEXT,
      null
    );
    const nodesToProcess = [];
    while (walker.nextNode()) {
      nodesToProcess.push(walker.currentNode);
    }
    nodesToProcess.forEach((node) => {
      const parent = node.parentNode;
      if (!parent) return;
      if (parent.nodeName === "CODE" || parent.nodeName === "PRE") {
        return;
      }
      const text = node.textContent || "";
      const hasCustomSyntax = text.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+|#)([.)]))(\s+)/) || text.match(/^(\s*)\(@[a-zA-Z0-9_-]*\)\s+/) || text.match(/^(\s*)[~:]\s+/) || text.match(/\(@[a-zA-Z0-9_-]+\)/);
      if (!hasCustomSyntax) {
        return;
      }
      const lines = text.split("\n");
      const newElements = [];
      lines.forEach((line, lineIndex) => {
        if (lineIndex > 0) {
          newElements.push(document.createTextNode("\n"));
        }
        let isDefinitionTerm = false;
        if (lineIndex < lines.length - 1) {
          const nextLine = lines[lineIndex + 1];
          if (nextLine && nextLine.match(/^(\s*)[~:]\s+/)) {
            isDefinitionTerm = true;
          }
        }
        const fancyMarker = parseFancyListMarker(line);
        if (fancyMarker) {
          const span = document.createElement("span");
          span.className = `pandoc-list-${fancyMarker.type}`;
          span.textContent = fancyMarker.marker + " ";
          newElements.push(span);
          const rest = line.substring(fancyMarker.indent.length + fancyMarker.marker.length + 1);
          if (rest) {
            newElements.push(document.createTextNode(rest));
          }
          return;
        }
        const exampleMarker = parseExampleListMarker(line);
        if (exampleMarker) {
          let number = 1;
          if (exampleMarker.label && exampleMap.has(exampleMarker.label)) {
            number = exampleMap.get(exampleMarker.label);
          }
          const span = document.createElement("span");
          span.className = "pandoc-example-list";
          span.textContent = `(${number}) `;
          newElements.push(span);
          const rest = line.substring(exampleMarker.indent.length + exampleMarker.originalMarker.length + 1);
          if (rest) {
            newElements.push(document.createTextNode(rest));
          }
          return;
        }
        const defMarker = parseDefinitionListMarker(line);
        if (defMarker && defMarker.type === "definition") {
          const span = document.createElement("span");
          span.textContent = "\u2022 ";
          newElements.push(span);
          newElements.push(document.createTextNode(defMarker.content));
          return;
        } else if (isDefinitionTerm && line.trim() && !line.match(/^(\s*)[~:]\s+/)) {
          const strong = document.createElement("strong");
          const u = document.createElement("u");
          u.textContent = line;
          strong.appendChild(u);
          newElements.push(strong);
          return;
        }
        const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
        let lastIndex = 0;
        let match;
        let hasReferences = false;
        while ((match = refRegex.exec(line)) !== null) {
          hasReferences = true;
          if (match.index > lastIndex) {
            newElements.push(document.createTextNode(line.substring(lastIndex, match.index)));
          }
          const label = match[1];
          if (exampleMap.has(label)) {
            const span = document.createElement("span");
            span.className = "pandoc-example-reference";
            span.textContent = `(${exampleMap.get(label)})`;
            newElements.push(span);
          } else {
            newElements.push(document.createTextNode(match[0]));
          }
          lastIndex = match.index + match[0].length;
        }
        if (hasReferences && lastIndex < line.length) {
          newElements.push(document.createTextNode(line.substring(lastIndex)));
        } else if (!hasReferences) {
          newElements.push(document.createTextNode(line));
        }
      });
      if (newElements.length > 0) {
        newElements.forEach((elem2) => {
          parent.insertBefore(elem2, node);
        });
        parent.removeChild(node);
      }
    });
  });
}

// src/ExampleReferenceSuggestFixed.ts
var import_obsidian2 = require("obsidian");
var ExampleReferenceSuggestFixed = class extends import_obsidian2.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.contains("(@")) return null;
    const matches = [...line.matchAll(/\(@/g)];
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterAt = line.substring(startIndex + 2);
    if (afterAt.contains(")")) return null;
    const query = afterAt;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const lines = doc.split("\n");
    const exampleData = /* @__PURE__ */ new Map();
    let counter = 1;
    for (const line of lines) {
      const match = line.match(/^\s*\(@([a-zA-Z0-9_-]+)\)\s+(.*)$/);
      if (match) {
        const label = match[1];
        const text = match[2].trim();
        if (!exampleData.has(label)) {
          exampleData.set(label, { number: counter, text });
        }
        counter++;
      } else if (line.match(/^\s*\(@\)\s+/)) {
        counter++;
      }
    }
    const suggestions = [];
    for (const [label, data] of exampleData) {
      if (!query || label.toLowerCase().startsWith(query.toLowerCase())) {
        let previewText = data.text;
        if (previewText.length > 30) {
          previewText = previewText.substring(0, 30) + "...";
        }
        suggestions.push({
          label,
          number: data.number,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: "pandoc-suggestion-content" });
    const title = container.createDiv({ cls: "pandoc-suggestion-title" });
    title.setText(`@${suggestion.label}`);
    const preview = container.createDiv({ cls: "pandoc-suggestion-preview" });
    preview.setText(suggestion.previewText);
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingParen = afterCursor.startsWith(")");
    let replacement;
    if (hasClosingParen) {
      replacement = `(@${suggestion.label}`;
    } else {
      replacement = `(@${suggestion.label})`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingParen) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/main.ts
var PandocListsPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("Loading Pandoc Lists plugin");
    this.registerEditorExtension(pandocListsExtension());
    this.registerMarkdownPostProcessor((element, context) => {
      processReadingMode(element, context);
    });
    this.suggester = new ExampleReferenceSuggestFixed(this);
    this.registerEditorSuggest(this.suggester);
    console.log("Pandoc Lists plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Pandoc Lists plugin");
  }
};
